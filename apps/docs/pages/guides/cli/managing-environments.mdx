import Layout from '~/layouts/DefaultGuideLayout'

export const meta = {
  id: 'managing-environments',
  title: '环境管理',
  description: '如何用CI/CD管道部署Supabase模式变化。',
}

## 概述

Supabase CLI 提供了你所需要的工具来管理多个环境。
本指南向您介绍如何设置您的本地 Supabase 开发环境，该环境与 GitHub Actions 集成，以自动
测试和发布模式变化到暂存和生产Supabase项目。

要开始使用。

- 安装Supabase CLI](/docs/guides/cli)
- 创建一个[MemFire Cloud项目](https://cloud.memfiredb.com)或使用一个现有的项目
- 初始化一个本地的 Git 仓库

<div className="video-container">
  <iframe
    src="https://www.youtube-nocookie.com/embed/rOLyOsBR1Uc"
    frameBorder="1"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowFullScreen
  ></iframe>
</div>

## 设置本地环境

第一步是用Supabase CLI设置你的本地存储库。

```bash
supabase init
```

你应该看到一个新的`supabase`目录。然后你需要将你的本地存储库与你的Supabase项目连接起来。

```bash
supabase login
supabase link --project-ref $PROJECT_ID
```

你可以从你项目的仪表盘URL中获得你的`$PROJECT_ID`。

```
https://app.supabase.com/project/<project-id>
```

如果你正在使用一个现有的Supabase项目，你可能已经通过Dashboard进行了模式更改。
在从 CLI 进行本地模式更改之前，请运行下面的命令来提取这些更改。

```sql
supabase db remote commit
```

这个命令在`supabase/migrations/<timestamp>_remote_commit.sql`中创建了一个新的迁移，反映了你之前所做的模式改变。

现在将你的本地修改提交给Git，并运行本地开发设置。

```bash
git add .
git commit -m "init supabase"
supabase start
```

现在你已经准备好在本地开发模式变化，并创建你的第一次迁移。

## 创建一个新的迁移

有两种方法可以对模式进行修改。

1. 手动迁移。手动将DDL语句写进迁移文件
1. 自动模式差异。通过Studio用户界面进行修改，并自动生成一个模式差异。

### 手动迁移

![手动迁移](/docs/img/guides/cli/diff-manual.png)

通过运行创建一个新的迁移脚本。

```bash
supabase migration new new_employee
```

你应该看到一个新的文件被创建。`supabase/migrations/<timestamp>_new_employee.sql`。然后你可以用文本编辑器在这个脚本中写SQL语句。

```sql
create table public.employees (
  id integer primary key generated always as identity,
  name text
);
```

将新的迁移应用到你的本地数据库。

```bash
supabase db reset
```

这个命令从头开始重新创建你的本地数据库，并应用`supabase/migrations`目录下的所有迁移脚本。现在你的本地数据库是最新的了。

<Admonition type="tip">

新的迁移命令还支持stdin作为输入。
这允许你从另一个文件或stdout管入一个现有的脚本。

`supabase migration new new_employee < create_employees_table.sql`。

</Admonition>

### 自动模式差异

与手动迁移不同，自动模式差异是从已经应用于本地数据库的***变化中创建一个新的迁移脚本。

![自动模式差异](/docs/img/guides/cli/diff-auto.png)

使用Studio UI在 `public`模式下创建一个 `employees`表，默认情况下可以在[localhost:54323](http://localhost:54323/)访问。

接下来，通过运行以下命令生成一个模式差异。

```bash
supabase db diff -f new_employee
```

你应该看到一个新文件`supabase/migrations/<timestamp>_new_employee.sql`被创建。打开该文件并验证生成的DDL语句与下面的相同。

```sql
-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.

CREATE TABLE IF NOT EXISTS public.employees
(
    id integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    name text COLLATE pg_catalog."default",
    CONSTRAINT employees_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.employees
    OWNER to postgres;

GRANT ALL ON TABLE public.employees TO anon;

GRANT ALL ON TABLE public.employees TO authenticated;

GRANT ALL ON TABLE public.employees TO postgres;

GRANT ALL ON TABLE public.employees TO service_role;
```

你可能会注意到，自动生成的迁移脚本比手工编写的脚本更加冗长。
这是因为默认的模式差异工具并没有考虑到初始模式所增加的默认权限。

将新的迁移脚本提交到git，就可以进行部署了。

<Admonition type="tip">

另外，你也可以传入`--use-migra`实验性标志，使用[migra](https://github.com/djrobstep/migra)生成一个更简洁的迁移。
如果没有`-f`文件标志，默认情况下输出会写到stdout。

`supabase db diff --use-migra`。

</Admonition>

## 部署迁移

在生产环境中，我们建议使用CI/CD管道来部署带有GitHub Actions的新迁移，而不是从你的本地机器上进行部署。

![部署迁移](/docs/img/guides/cli/cicd-github.png)

这个例子使用了两个Supabase项目，一个用于生产，一个用于暂存。

通过以下方式准备你的环境。

- 创建独立的Supabase项目，用于暂存和生产
- 将你的 git 仓库推送到 GitHub 并启用 GitHub 操作

<Admonition type="caution">

你需要一个新的项目来进行暂存。一个已经被修改以反映生产项目模式的项目不能被使用，因为CLI会重新应用这些修改。

</Admonition>

### 配置GitHub操作

Supabase CLI需要一些环境变量才能在非交互式模式下运行。

- `SUPABASE_ACCESS_TOKEN`是你的个人访问令牌
- `SUPABASE_DB_PASSWORD`是你的项目特定数据库密码

我们建议将这些作为[加密的秘密](https://docs.github.com/en/actions/security-guides/encrypted-secrets)添加到你的GitHub行动运行器中。

在`.github/workflows`目录下创建以下文件。

<Tabs
  scrollable
  size="small"
  type="underlined"
  defaultActiveId="ci"
>
<TabPanel id="ci" label="ci.yaml">

```yaml title=.github/workflows/ci.yml
name: CI

on:
  pull_request:
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v3

      - uses: supabase/setup-cli@v1
        with:
          version: 1.0.0

      - name: Start Supabase local development setup
        run: supabase start

      - name: Verify generated types are up-to-date
        run: |
          supabase gen types typescript --local > types.ts
          if [ "$(git diff --ignore-space-at-eol types.ts | wc -l)" -gt "0" ]; then
            echo "Detected uncommitted changes after build. See status below:"
            git diff
            exit 1
          fi
```

</TabPanel>
<TabPanel id="staging" label="staging.yaml">

```yaml title=.github/workflows/staging.yml
name: Deploy Migrations to Staging

on:
  push:
    branches:
      - develop
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-22.04

    env:
      SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
      SUPABASE_DB_PASSWORD: ${{ secrets.STAGING_DB_PASSWORD }}
      STAGING_PROJECT_ID: abcdefghijklmnopqrst

    steps:
      - uses: actions/checkout@v3

      - uses: supabase/setup-cli@v1
        with:
          version: 1.0.0

      - run: |
          supabase link --project-ref $STAGING_PROJECT_ID
          supabase db push
```

</TabPanel>
<TabPanel id="production" label="production.yaml">

```yaml title=.github/workflows/production.yml
name: Deploy Migrations to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-22.04

    env:
      SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
      SUPABASE_DB_PASSWORD: ${{ secrets.PRODUCTION_DB_PASSWORD }}
      PRODUCTION_PROJECT_ID: abcdefghijklmnopqrst

    steps:
      - uses: actions/checkout@v3

      - uses: supabase/setup-cli@v1
        with:
          version: 1.0.0

      - run: |
          supabase link --project-ref $PRODUCTION_PROJECT_ID
          supabase db push
```

</TabPanel>
</Tabs>

完整的示例代码可在[demo repository](https://github.com/supabase/supabase-action-example)中找到。

将这些文件提交到git，并推送到GitHub上的`main`分支。更新这些环境变量以匹配你的Supabase项目。

- `supabase_access_token`
- `production_project_id`(生产项目名称)
- 生产数据库密码。
- Staging_project_id
- `staging_db_password`

当配置正确时，你的版本库将有CI和Release工作流，在推送到`main`和`develop`分支的新提交时触发。

![正确配置的版本库](/docs/img/guides/cli/ci-main.png)

### 用新的迁移方式打开一个PR

按照[迁移步骤](#create-a-new-migration)创建一个`supabase/migrations/<timestamp>_new_employee.sql`文件。

从`develop`签出一个新的分支`feat/employee`，提交迁移文件，并推送到GitHub。

```bash
git checkout -b feat/employee
git add supabase/migrations/<timestamp>_new_employee.sql
git commit -m "Add employee table"
git push --set-upstream origin feat/employee
```

从`feat/employee`打开一个PR到`develop`分支，看看CI工作流程是否已经被触发。

一旦测试错误被解决，合并这个PR，观察部署的动作。

### 发布到生产

在确认你的暂存项目已经成功迁移后，从`develop`到`main`创建另一个PR，并合并它，将迁移部署到生产项目中。

![合并新的PR](/docs/img/guides/cli/ci-release.png)

`release`作业将所有合并在`supabase/migrations`目录下的新迁移脚本应用到一个被链接的Supabase项目。你可以通过`PROJECT_ID`环境变量来控制作业链接到哪个项目。

## 故障排除

### 将生产项目同步到暂存项目

在建立一个新的暂存项目时，你可能需要将初始模式与之前应用于生产项目的迁移同步。

一种方法是利用发布工作流程。

- 创建一个新的分支`develop`并选择`main`作为分支源
- 推送`develop`分支到GitHub

GitHub Actions runner会将你现有的迁移部署到暂存项目中。

另外，你也可以通过本地CLI将迁移应用到链接的远程数据库。

```sql
supabase db push
```

一旦推送，检查本地和远程数据库的迁移版本是否为最新的。

```sql
supabase migration list
```

### db远程提交的权限被拒绝

如果你已经使用Supabase托管的项目很长时间了，在执行`db远程提交`时可能会遇到以下权限错误。

```bash
Error: Error running pg_dump on remote database: pg_dump: error: query failed: ERROR:  permission denied for table _type

pg_dump: error: query was: LOCK TABLE "graphql"."_type" IN ACCESS SHARE MODE
```

为了解决这个错误，你需要授予`postgres`角色权限给`graphql`模式。你可以通过在Supabase仪表板的SQL编辑器中运行以下查询来实现。

```sql
grant all on all tables in schema graphql to postgres, anon, authenticated, service_role;
grant all on all functions in schema graphql to postgres, anon, authenticated, service_role;
grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;
```

### 在数据库推送时被拒绝的权限

如果你通过Supabase仪表盘创建了一个表，并且你的新迁移脚本包含`ALTER TABLE`语句，当你在暂存数据库或生产数据库上应用这些语句时，可能会遇到权限错误。

```bash
ERROR: must be owner of table employees (SQLSTATE 42501); while executing migration <timestamp>
```

这是因为通过Supabase仪表板创建的表是由`supabase_admin`角色拥有的，而通过CLI执行的迁移脚本是在`postgres`角色下。

解决这个问题的方法之一是将这些表的所有者重新分配给`postgres`角色。例如，如果你的表在公共模式中被命名为 "users"，你可以运行以下命令来重新分配所有者。

```sql
ALTER TABLE users OWNER TO postgres;
```

除了表之外，你还需要使用各自的命令来重新分配其他实体的所有者，包括[types](https://www.postgresql.org/docs/current/sql-alterschema.html), [function](https://www.postgresql.org/docs/current/sql-alterroutine.html), 和[schemas](https://www.postgresql.org/docs/current/sql-altertype.html)。

### 重置新的迁移

有时候，你的队友可能会将一个新的迁移文件合并到git主分支上，现在你需要在上面重设你的本地模式修改。

![Rebase on main](/docs/img/guides/cli/rebase.png)

我们可以通过用新的时间戳重命名你的旧迁移文件来优雅地处理这种情况。

```bash
git pull
supabase migration new dev_A
# Assume the new file is: supabase/migrations/<t+2>_dev_A.sql
mv <time>_dev_A.sql <t+2>_dev_A.sql
supabase db reset
```

如果[`reset`](/docs/reference/cli/usage#supabase-db-reset)失败，你可以通过编辑`<t+2>_dev_A.sql`文件手动解决冲突。

本地验证后，将你的修改提交给Git并推送到GitHub。

export const Page = ({ children }) => <Layout meta={meta} children={children} />

export default Page
